name: Deploy/Destroy EC2 Dashboard

on:
  workflow_dispatch:
    inputs:
      ACTION:
        description: "Choose 'deploy' to apply or 'destroy' to tear down"
        required: true
        default: "deploy"
        type: choice
        options: [deploy, destroy]
      ENVIRONMENT:
        description: "GitHub Environment name (must exist)"
        required: true
        default: "mypersonalAWS"
      AWS_REGION:
        description: "AWS Region"
        required: true
        default: "us-east-2"
      WEBSITE_BUCKET_NAME:
        description: "(Optional) S3 bucket name for site (blank to auto-generate)"
        required: false
        default: ""
      ALLOWED_EMAIL_DOMAIN:
        description: "Allowed email domain for OTP/login (deploy only)"
        required: false
        default: "gmail.com"
      SES_SENDER_EMAIL:
        description: "SES verified sender address (deploy only)"
        required: false
        default: "noreplyzingamazigle@gmail.com"
      ASSIGN_PROFILE_TARGET:
        description: "Attach SSM instance profile to which EC2s?"
        required: true
        default: "both"
        type: choice
        options: [none, running, stopped, both]
      TF_BACKEND_BUCKET:
        description: "(Optional) Pre-existing S3 bucket for TF state. Leave blank to auto-create."
        required: false
        default: ""
      TF_LOCK_TABLE:
        description: "(Optional) Pre-existing DynamoDB lock table. Leave blank to auto-create."
        required: false
        default: ""

jobs:
  run:
    runs-on: ubuntu-latest
    environment: ${{ inputs.ENVIRONMENT }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (from environment secrets)
        run: |
          mkdir -p ~/.aws
          cat > ~/.aws/credentials <<EOF
          [default]
          aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          EOF
          cat > ~/.aws/config <<EOF
          [default]
          region=${{ inputs.AWS_REGION }}
          output=json
          EOF

      - name: Bootstrap Terraform backend (S3 + DynamoDB)
        id: backend
        shell: bash
        run: |
          set -euo pipefail
          REGION="${{ inputs.AWS_REGION }}"
          ENVNAME="${{ inputs.ENVIRONMENT }}"
          USER_BUCKET="${{ inputs.TF_BACKEND_BUCKET }}"
          USER_TABLE="${{ inputs.TF_LOCK_TABLE }}"
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

          sanitize_bucket() {
            local raw="$1"
            local s
            s="$(printf '%s' "$raw" | tr '[:upper:]' '[:lower:]' | tr -c 'a-z0-9-' '-')"
            s="$(printf '%s' "$s" | sed -E 's/-{2,}/-/g; s/^-+//; s/-+$//')"
            s="${s:0:63}"
            s="$(printf '%s' "$s" | sed -E 's/-+$//')"
            if [ ${#s} -lt 3 ]; then
              s="tfstate-${ACCOUNT_ID}-${REGION}"
              s="$(printf '%s' "$s" | tr '[:upper:]' '[:lower:]' | tr -c 'a-z0-9-' '-')"
              s="$(printf '%s' "$s" | sed -E 's/-{2,}/-/g; s/^-+//; s/-+$//')"
              s="${s:0:63}"
              s="$(printf '%s' "$s" | sed -E 's/-+$//')"
            fi
            if ! [[ "${s: -1}" =~ [a-z0-9] ]]; then
              s="$(printf '%s' "${s%?}")"
            fi
            printf '%s' "$s"
          }

          if [ -z "$USER_BUCKET" ]; then
            RAW="tfstate-${ENVNAME}-${ACCOUNT_ID}-${REGION}"
            BUCKET="$(sanitize_bucket "$RAW")"
          else
            BUCKET="$(sanitize_bucket "$USER_BUCKET")"
          fi

          if [ -z "$USER_TABLE" ]; then
            TABLE="tf-lock-${ENVNAME}"
          else
            TABLE="$USER_TABLE"
          fi

          echo "Using backend bucket: $BUCKET"
          echo "Using lock table   : $TABLE"

          if aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
            echo "Bucket exists"
          else
            if [ "$REGION" = "us-east-1" ]; then
              aws s3api create-bucket --bucket "$BUCKET"
            else
              aws s3api create-bucket --bucket "$BUCKET" --create-bucket-configuration LocationConstraint="$REGION"
            fi
          fi

          aws s3api put-bucket-versioning --bucket "$BUCKET" --versioning-configuration Status=Enabled
          aws s3api put-bucket-encryption --bucket "$BUCKET" --server-side-encryption-configuration '{
            "Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]
          }'
          aws s3api put-public-access-block --bucket "$BUCKET" --public-access-block-configuration '{
            "BlockPublicAcls":true,"IgnorePublicAcls":true,"BlockPublicPolicy":true,"RestrictPublicBuckets":true
          }'

          if aws dynamodb describe-table --table-name "$TABLE" >/dev/null 2>&1; then
            echo "Table exists"
          else
            aws dynamodb create-table \
              --table-name "$TABLE" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region "$REGION"
            aws dynamodb wait table-exists --table-name "$TABLE" --region "$REGION"
          fi

          echo "bucket=$BUCKET" >> "$GITHUB_OUTPUT"
          echo "table=$TABLE"   >> "$GITHUB_OUTPUT"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ steps.backend.outputs.bucket }}" \
            -backend-config="key=env/${{ inputs.ENVIRONMENT }}/terraform.tfstate" \
            -backend-config="region=${{ inputs.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ steps.backend.outputs.table }}"

      # -------------------- DEPLOY --------------------
      - name: Terraform Apply
        if: ${{ inputs.ACTION == 'deploy' }}
        env:
          TF_VAR_aws_region: ${{ inputs.AWS_REGION }}
          TF_VAR_allowed_email_domain: ${{ inputs.ALLOWED_EMAIL_DOMAIN }}
          TF_VAR_ses_sender_email: ${{ inputs.SES_SENDER_EMAIL }}
          TF_VAR_website_bucket_name: ${{ inputs.WEBSITE_BUCKET_NAME }}
          TF_VAR_assign_profile_target: ${{ inputs.ASSIGN_PROFILE_TARGET }}
        run: terraform apply -auto-approve

      - name: Capture outputs (deploy)
        if: ${{ inputs.ACTION == 'deploy' }}
        id: out
        run: |
          set +e
          terraform output -raw api_endpoint      > .api.txt   2>/dev/null || true
          terraform output -raw cloudfront_domain > .cf.txt    2>/dev/null || true
          terraform output -raw site_bucket       > .site.txt  2>/dev/null || true
          terraform output -raw cloudfront_id     > .cfid.txt  2>/dev/null || true
          set -e
          echo "api=$(cat .api.txt  || true)"   >> $GITHUB_OUTPUT
          echo "cf=$(cat .cf.txt   || true)"    >> $GITHUB_OUTPUT
          echo "site=$(cat .site.txt|| true)"   >> $GITHUB_OUTPUT
          echo "cfid=$(cat .cfid.txt|| true)"   >> $GITHUB_OUTPUT

      - name: Build site (inject API + domain)
        if: ${{ inputs.ACTION == 'deploy' }}
        run: |
          mkdir -p dist
          cp -r html/* dist/
          sed -i "s|\${api_base_url}|${{ steps.out.outputs.api }}|g" dist/index.html.tpl
          sed -i "s|\${api_base_url}|${{ steps.out.outputs.api }}|g" dist/login.html || true
          sed -i "s|\${allowed_email_domain}|${{ inputs.ALLOWED_EMAIL_DOMAIN }}|g" dist/index.html.tpl
          mv dist/index.html.tpl dist/index.html

      - name: Upload to S3 (deploy)
        if: ${{ inputs.ACTION == 'deploy' }}
        run: aws s3 sync dist s3://${{ steps.out.outputs.site }} --delete --acl private

      - name: Invalidate CloudFront cache (deploy)
        if: ${{ inputs.ACTION == 'deploy' && steps.out.outputs.cfid != '' }}
        run: aws cloudfront create-invalidation --distribution-id "${{ steps.out.outputs.cfid }}" --paths "/*"

      # -------------------- DESTROY --------------------
      - name: Empty website bucket (destroy â€“ optional)
        if: ${{ inputs.ACTION == 'destroy' }}
        continue-on-error: true
        run: |
          SITE=$(terraform output -raw site_bucket 2>/dev/null || true)
          if [ -n "$SITE" ]; then
            aws s3 rm s3://$SITE --recursive || true
          fi

      - name: Terraform Destroy
        if: ${{ inputs.ACTION == 'destroy' }}
        env:
          TF_VAR_aws_region: ${{ inputs.AWS_REGION }}
          TF_VAR_allowed_email_domain: ${{ inputs.ALLOWED_EMAIL_DOMAIN }}
          TF_VAR_ses_sender_email: ${{ inputs.SES_SENDER_EMAIL }}
          TF_VAR_website_bucket_name: ${{ inputs.WEBSITE_BUCKET_NAME }}
          TF_VAR_assign_profile_target: ${{ inputs.ASSIGN_PROFILE_TARGET }}
        run: terraform destroy -auto-approve
